---
layout:     post
title:      ---
layout:     post
title:      漫画算法(一)
subtitle:   算法概念与数据结构简要
date:       2020-04-13
author:     worldly
header-img: img/post-bg-tech-14.jpg
catalog: true
tags:
    - JS
---

### 前言
虽然前端很多工作用不上算法，但我认为作为一枚软件工程师，不懂数据结构和算法是会被同行鄙视的，何况这本身都属于必会的基础知识了。最近在阅读去年市场上新出的一本书《漫画算法》，全书以漫画的形式简述了数据结构和常见的算法，作为算法入门书籍还是蛮适合的。

#### 一、算法概念
*算法* 在数学中可理解为运算数字的方法，例如 *高斯算法*、*二分算法* 等。放在计算机中其实跟数学差不多，可变相理解为运用数学中运算的算法思想解决计算机中的逻辑问题。

那用什么来衡量一个算法的好坏了？由此而衍生出了下面两个概念，*时间复杂度* 和 *空间复杂度*, *时间复杂度* 反映了运行时的时效问题，即程序运行完所用的时间。*空间复杂度* 反映了存储问题，即程序运行时所占的存储空间。

##### 1、时间复杂度

> “若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度”

如何计算时间复杂度：
* 如果运行时间是常数量级，则用常数1表示
* 只保留时间函数中的最高阶项
* 如果最高阶项存在，则省去最高阶项前面的系数

时间复杂度排序：

> O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)


##### 2、空间复杂度

> “空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作S(n)=O(f(n))”

空间复杂度排序：

> O(1) < O(n) < O(n^2)


#### 二、数据结构

> 物理结构和逻辑结构 ?

*物理结构* 是内存中实实在在存在的，如数组和链表。*逻辑结构* 是抽象化的概念，依赖于物理结构而存在，如栈和队列

![](http://local.fenzhitech.com:81/res/01e2e80b770adc9b579a5360e30b2f76.png)

##### 1、数组

> “数组是由有限个相同类型的变量所组成的有序集合”

* 物理存储方式：顺序存储
* 访问方式：随机访问
* 下标查找元素时间复杂度：O(1)
* 中间插入、删除数组的时间复杂度：O(n)

##### 2、链表

> “链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针”

* 物理存储方式：随机存储
* 访问方式：顺序访问
* 下标查找元素时间复杂度：O(n)
* 中间插入、删除数组的时间复杂度：O(1)

##### 3、栈

> “遵循先进后出原则的一种线性逻辑结构”

##### 4、队列

> “遵循先进先出原则的一种线性逻辑结构”

##### 5、散列表

> “散列表也叫作哈希表（hash table），提供了键（Key）和值（Value）的映射关系”

* 读写操作：时间复杂度接近 O(1)

##### 6、树

> “树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n>1时，其余节点可分为m个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树”

* 二叉树：每个节点都最多只有两个子节点
* 满二叉树：二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上

![](http://local.fenzhitech.com:81/res/e930ce10043de17631f1d1707ea1430b.png)

* 完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树

![](http://local.fenzhitech.com:81/res/995ba389bb54395a9b2ffea0de95f785.png)

* 二叉堆：一种特殊的完全二叉树，分为最大堆和最小堆
* 最大堆：任意一个父节点的值都大于或者等于其左右孩子节点的值

![](http://local.fenzhitech.com:81/res/77e015515b25ea95064caf3f4edbb377.png)

* 最小堆：任意一个父节点的值都小于或者等于其左右孩子节点的值

![](http://local.fenzhitech.com:81/res/995ba389bb54395a9b2ffea0de95f785.png)

* 最大优先队列：基于最大堆实现，无论入队顺序如何，当前最大的元素都会优先出队
* 最小优先队列：基于最小堆实现，无论入队顺序如何，当前最小的元素都会优先出队
